#!/bin/bash
# =============================================================================
# General Seismic Velocity Model Update Workflow
# Author:   Lining Yang
# Date:     2025-07-11 16:00:00 
# Modified: 2025-07-15 17:10:10
# Version:  1.2
# License:  BSD 3-Clause License
# =============================================================================
#
# Description:
#   This script updates seismic velocity models using residual moveout analysis.
#   It combines Shell scripting for workflow control and Fortran for interpolation.
#
#   **Difference from UpdateV2M.sh:**
#   - This script does NOT apply water bottom (seafloor) constraints.
#   - Suitable for land or general seismic velocity model updating.
#   - For marine data with water bottom constraint, use UpdateV2M.sh.
#
# Input Files (must exist in working directory):
#   - vfile           : Initial velocity model (Binary, Fortran-order, nz*nx)
#   - residuotot.dat  : Residual picks for all CDPs (generated by VelocityAnalysis.sh)
#   - v.par_v         : Automatically generate if not present at the first run.
#                       Grid parameters (ASCII, 9 values: nz, dz, fz, nx, dx, fx, cdpmin, cdpmax, dcdp)
#
# Output Files:
#   - velres.dat      : Gridded residual velocity (ASCII, nz*nx lines, Fortran-order)
#   - vfile.updated   : Updated velocity model (ASCII, nz*nx lines, Fortran-order)
#   - vfile           : Final velocity model (overwrites original, Fortran-order)
#   - vfile_old       : Backup of original vfile (ASCII, nz*nx lines, Fortran-order)
#
# Intermediate Files (auto-cleaned):
#   - vfile.a, picking_cig, residuo.txt, residuotot.dat, deltap.txt, numeropick.txt, cig.txt, tmp.su, filecigtot.su
#
# Dependencies:
#   - Seismic Unix (SU) tools: suwind, suxwigb, surelan, suchw, suximage, dzdv, velpert
#   - Fortran compiler (gfortran)
#   - Embedded Fortran code: faivelres (for velocity residual interpolation)
#
# Usage:
#   - Step 1: ./CIG_extract.sh       # Extract CDP traces and create kd.data and outfile1
#   - Step 2: ./VelocityAnalysis.sh  # Generate residuotot.dat
#   - Step 3: ./UpdateV.sh           # Auto-handles parameters
#
# Notes:
#   - All intermediate and output files are overwritten in each run.
#   - Ensure all required input files are present in the working directory.
#   - This script does NOT require mpicks.$cdp or residuo.$cdp files.
# =============================================================================
#
# v.par_v parameter file format:
#   Supports both single-line and multi-line (recommended) formats:
#   Multi-line (recommended):
#     nz
#     dz
#     fz
#     nx
#     dx
#     fx
#     cdpmin
#     cdpmax
#     dcdp
#   Or single-line (space-separated):
#     nz dz fz nx dx fx cdpmin cdpmax dcdp
#   You can choose:
#     1. Interactive input and generate v.par_v
#     2. Use built-in default parameters to generate v.par_v
#     3. Use existing v.par_v file
# =============================================================================

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
DEBUG_MODE=1  # Set to 1 for detailed output, 0 for minimal output

# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------
log() {
    local level=$1
    local message=$2
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    case $level in
        error) echo -e "\033[31m[ERROR] $timestamp - $message\033[0m" >&2 ;;
        warn)  echo -e "\033[33m[WARN]  $timestamp - $message\033[0m" >&2 ;;
        info)  echo -e "\033[32m[INFO]  $timestamp - $message\033[0m" ;;
        debug) [ "$DEBUG_MODE" -eq 1 ] && echo "[DEBUG] $timestamp - $message" ;;
    esac
}

validate_number() {
    local value=$1
    local name=$2
    if ! [[ "$value" =~ ^[0-9]+$ ]] || [ "$value" -le 0 ]; then
        log error "Invalid $name value: $value"
        return 1
    fi
    return 0
}

validate_float() {
    local value=$1
    local name=$2
    if ! [[ "$value" =~ ^[0-9.]+$ ]]; then
        log error "Invalid $name value: $value"
        return 1
    fi
    return 0
}

# -----------------------------------------------------------------------------
# Input File Check Function
# -----------------------------------------------------------------------------
check_input_files() {
    local missing=0
    local files=("vfile" "residuotot.dat") # v.par_v is handled separately
    for file in "${files[@]}"; do
        if [ ! -f "$file" ]; then
            log error "Missing required input file: $file"
            missing=1
        fi
    done
    if [ $missing -eq 1 ]; then
        log error "One or more required input files are missing. Exiting."
        exit 2
    fi
}

# -----------------------------------------------------------------------------
# Parameter File Handling
# -----------------------------------------------------------------------------
choose_param_mode() {

    # If v.par_v exists and FORCE_PARAM_MENU is not set, use it directly
    if [ -f "v.par_v" ] && [ -z "$FORCE_PARAM_MENU" ]; then
        log info "Using existing v.par_v"
        return 0
    fi

    echo "-------------------------------------------------------------"
    echo "v.par_v parameter file handling:"
    echo "  1. Interactive input and generate v.par_v"
    echo "  2. Use built-in default parameters to generate v.par_v"
    echo "  3. Use existing v.par_v file"
    echo "-------------------------------------------------------------"
    
    if [ ! -f "v.par_v" ] && [ -z "$mode" ]; then
        log info "Auto-generating default v.par_v"
        echo "321 25 0 701 100 0 6000 65000 500" > v.par_v
        return
    fi

    # local mode
    while true; do
        read -rp "Choose parameter input mode [1/2/3] (default 2): " mode
        mode=${mode:-2}  # 默认选择2
        case "$mode" in
            1)
                echo "Please input parameters (press Enter after each):"
                read -rp "nz = " nz
                read -rp "dz = " dz
                read -rp "fz = " fz
                read -rp "nx = " nx
                read -rp "dx = " dx
                read -rp "fx = " fx
                read -rp "cdpmin = " cdpmin
                read -rp "cdpmax = " cdpmax
                read -rp "dcdp = " dcdp
                echo -e "$nz\n$dz\n$fz\n$nx\n$dx\n$fx\n$cdpmin\n$cdpmax\n$dcdp" > v.par_v
                log info "Generated v.par_v via interactive input"
                break
                ;;
            2)
                echo "321 25 0 701 100 0 15000 25000 500" > v.par_v
                log info "Default parameters written to v.par_v: 321 25 0 701 100 0 15000 25000 500"
                break
                ;;
            3)
                if [ ! -f v.par_v ]; then
                    log error "v.par_v does not exist, please choose another mode"
                else
                    log info "Using existing v.par_v"
                    break
                fi
                ;;
            *)
                echo "Invalid choice, please enter 1, 2, or 3"
                ;;
        esac
    done
}

# -----------------------------------------------------------------------------
# Compile Embedded Fortran Program (faivelres)
# -----------------------------------------------------------------------------
# =============================================================================
# Embedded Fortran Program: faivelres
#
# Purpose:
#   Interpolates residual velocity picks (from residuotot.dat) onto a regular
#   grid defined by v.par_v, producing a gridded residual velocity field
#   (velres.dat) for subsequent model updating.
#
# Inputs:
#   - residuotot.dat : Residual picks for all CDPs (ASCII)
#   - v.par_v        : Grid parameters (ASCII, 9 lines: nz, dz, fz, nx, dx, fx, cdpmin, cdpmax, dcdp)
#
# Outputs:
#   - velres.dat     : Gridded residual velocity (ASCII, nz*nx lines)
#
# Notes:
#   - No water bottom (seafloor) constraint is applied.
#   - The Fortran code is embedded and auto-compiled by the script.
#   - Original Author: Umberta Tinivella, OGS, Udine, Italy
# https://github.com/Dai411/ISTRICI-OGS/blob/main/TRAD_V1/faivelres_dettaglio.f
#   - Modified by: Lining YANG, CNR-ISMAR Bologna
# =============================================================================
FORT_FAIVELRES_CODE=$(cat <<'EOF'
program faivelres
    integer, parameter :: maxpicks = 100  ! Maximum picks per CDP
    real, allocatable :: res(:,:,:), resint(:,:)
    integer :: nz, dz, fz, nx, dx, fx, cdpmin, cdpmax, dcdp
    integer :: i, j, k, ni, ncdp, nmin, nmax, nstep, nvalido, nc
    real :: cdp, z, r, xlam, x, xm, xq

    ! Read grid parameters
    open(12, file='v.par_v')
    read(12, *) nz
    read(12, *) dz
    read(12, *) fz
    read(12, *) nx
    read(12, *) dx
    read(12, *) fx
    read(12, *) cdpmin
    read(12, *) cdpmax
    read(12, *) dcdp
    close(12)

    ! Allocate arrays
    allocate(res(nx, maxpicks, 4))
    allocate(resint(nx, nz))
    res = 0.0
    resint = 0.0

    ! Read residual picks
    open(10, file='residuotot.dat')
10  read(10, *, end=99) nc
    do i = 1, nc
        read(10, *) cdp, z, r, xlam
        ncdp = int(cdp)
        ni = (ncdp - fx) / dx + 1
        if (ni >= 1 .and. ni <= nx .and. i <= maxpicks) then
            res(ni, i, 1) = z
            res(ni, i, 2) = r
            res(ni, i, 3) = xlam
            res(ni, i, 4) = real(nc)
        else
            print *, "Warning: Index out of bounds - ni:", ni, "i:", i
        endif
    enddo
    goto 10
99  close(10)

    ! Calculate index ranges
    nmin = (cdpmin - fx) / dx + 1
    nmax = (cdpmax - fx) / dx + 1
    nstep = dcdp / dx

    ! Vertical interpolation
    do i = nmin, nmax, nstep
        do j = 1, nz
            z = fz + dz * (j - 1)  ! 使用正确的 fz 变量
            
            ! Skip if no picks for this CDP (marked by 999)
            if (res(i, 1, 3) == 999) then
                resint(i, j) = 999
                cycle
            endif
            
            do k = 1, int(res(i, 1, 4))
                if (z <= res(i, k, 1) .and. k == 1) then
                    resint(i, j) = res(i, k, 3)
                    exit
                endif
                
                if (z > res(i, k, 1) .and. k /= int(res(i, 1, 4)) .and. &
                    z <= res(i, k+1, 1)) then
                    xm = (res(i, k+1, 3) - res(i, k, 3)) / &
                         (res(i, k+1, 1) - res(i, k, 1))
                    xq = res(i, k, 3) - xm * res(i, k, 1)
                    resint(i, j) = xm * z + xq
                    exit
                endif
                
                if (k == int(res(i, 1, 4))) then
                    resint(i, j) = res(i, k, 3)
                    exit
                endif
            enddo
        enddo
    enddo

    ! Handle missing data (999) - part 1: fix first and last CDPs
    if (resint(nmin, 1) == 999) then
        do k = nmin + nstep, nmax, nstep
            if (resint(k, 1) /= 999) then
                do j = 1, nz
                    resint(nmin, j) = resint(k, j)
                enddo
                exit
            endif
        enddo
    endif

    if (resint(nmax, 1) == 999) then
        do k = nmax - nstep, nmin, -nstep
            if (resint(k, 1) /= 999) then
                do j = 1, nz
                    resint(nmax, j) = resint(k, j)
                enddo
                exit
            endif
        enddo
    endif

    ! Handle missing data (999) - part 2: fix intermediate CDPs
    do i = nmin, nmax, nstep
        if (resint(i, 1) == 999) then
            ! Find next valid CDP to the right
            do k = i + nstep, nmax, nstep
                if (resint(k, 1) /= 999) then
                    nvalido = k
                    exit
                endif
            enddo
            
            ! Linear interpolation in x-direction
            do j = 1, nz
                x = fx + (i - 1) * dx
                xm = (resint(i - nstep, j) - resint(nvalido, j)) / &
                     ((nvalido - i + nstep) * dx)
                xq = resint(i - nstep, j) - xm * (fx + (i - nstep - 1) * dx)
                resint(i, j) = xm * x + xq
            enddo
        endif
    enddo

    ! Horizontal interpolation for all CDP indices
    do j = 1, nz
        do i = 1, nx
            x = fx + (i - 1) * dx
            
            ! Extrapolate for i <= nmin
            if (i <= nmin) then
                resint(i, j) = 0.0  ! Original code used 0.0
                cycle
            endif
            
            ! Extrapolate for i >= nmax
            if (i >= nmax) then
                resint(i, j) = 0.0  ! Original code used 0.0
                cycle
            endif
            
            ! Find the step index for current i
            nk = nmin + ((i - nmin) / nstep) * nstep
            if (nk < nmin) nk = nmin
            if (nk >= nmax) nk = nmax - nstep
            
            ! Linear interpolation between nk and nk + nstep
            xm = (resint(nk + nstep, j) - resint(nk, j)) / (nstep * dx)
            xq = resint(nk, j) - xm * (fx + (nk - 1) * dx)
            resint(i, j) = xm * x + xq
        enddo
    enddo

    ! Write results
    open(50, file='velres.dat')
    do i = 1, nx
        do j = 1, nz
            write(50, *) resint(i, j)
        enddo
    enddo
    close(50)
    
    deallocate(res, resint)
    print *, "Successfully generated velres.dat"
end program
EOF
)

# -----------------------------------------------------------------------------
# Compile Embedded Fortran Program (faivelres)
# Compared to the original, this is a more modern Fortran style
# .f90 is the preferred extension for modern Fortran code
# .f90 files are free-form, allowing for better readability and maintainability 
# -----------------------------------------------------------------------------
compile_embedded_faivelres() {
    local program="faivelres"
    local source_code="$FORT_FAIVELRES_CODE"
    local source_hash=$(echo "$source_code" | sha256sum | cut -d' ' -f1)
    if [ -f "./$program" ] && [ -f "./${program}.hash" ]; then
        local stored_hash=$(cat "./${program}.hash")
        if [ "$stored_hash" == "$source_hash" ]; then
            log info "Using existing binary: $program (code hash matches)"
            return 0
        else
            log info "Source code changed. Recompiling $program..."
            rm -f "./$program"
        fi
    fi
    log info "Compiling $program (embedded Fortran)..."
    local source_file="${program}.f90" 
    echo "$source_code" > "$source_file"
    #gfortran -O3 -ffixed-form -o "$program" "$source_file" #Old style
    gfortran -O3 -free -o "$program" "$source_file"

    if [ $? -ne 0 ] || [ ! -f "./$program" ]; then
        log error "Failed to compile $program"
        log error "Source file preserved for debugging: $source_file"
        exit 1
    fi
    echo "$source_hash" > "./${program}.hash"
    log info "Successfully compiled $program"
}

# -----------------------------------------------------------------------------
# Add velocity models (replaces sommavel.f)
# -----------------------------------------------------------------------------
add_velocity_models() {
    log info "Adding velocity models..."
    local required_files=("velres.dat" "vfile.a" "v.par_v")
    for file in "${required_files[@]}"; do
        if [ ! -f "$file" ]; then
            log error "Missing required file: $file"
            return 1
        fi
    done
    local params=()
    while IFS= read -r line; do
        for val in $line; do
            params+=($val)
        done
    done < "v.par_v"
    if [ ${#params[@]} -lt 9 ]; then
        log error "v.par_v must contain at least 9 values (found ${#params[@]})"
        return 1
    fi
    local nz=${params[0]} dz=${params[1]} fz=${params[2]}
    local nx=${params[3]} dx=${params[4]} fx=${params[5]}
    local ncdpmin=${params[6]} cdpmax=${params[7]} dcdp=${params[8]}
    validate_number "$nz" "nz" || return 1
    validate_float "$dz" "dz" || return 1
    validate_float "$fz" "fz" || return 1
    validate_number "$nx" "nx" || return 1
    validate_float "$dx" "dx" || return 1
    validate_float "$fx" "fx" || return 1
    local total_points=$((nx * nz))
    log info "Grid dimensions: ${nx}x${nz} = $total_points points"
    local velres_lines=$(wc -l < "velres.dat")
    local vfile_lines=$(wc -l < "vfile.a")
    if [ "$velres_lines" -ne "$total_points" ]; then
        log error "velres.dat size mismatch (expected: $total_points, actual: $velres_lines)"
        return 1
    fi
    if [ "$vfile_lines" -ne "$total_points" ]; then
        log error "vfile.a size mismatch (expected: $total_points, actual: $vfile_lines)"
        return 1
    fi
    local start_time=$(date +%s.%N)
    paste "vfile.a" "velres.dat" | awk -v total="$total_points" '
    BEGIN {
        count = 0
        step = (total > 100) ? int(total/100) : 1
        print "0% completed" > "/dev/stderr"
    }
    {
        count++
        if (step > 0 && count % step == 0) {
            progress = int(count/total*100)
            printf "\rProcessing: %d%% completed", progress > "/dev/stderr"
            system("") # Flush output buffer
        }
        printf "%.8f\n", $1 + $2
    }
    END {
        if (total > 0) printf "\rProcessing: 100%% completed\n" > "/dev/stderr"
    }' > "vfile.updated"
    local end_time=$(date +%s.%N)
    local elapsed=$(echo "$end_time - $start_time" | bc -l)
    local points_per_sec=$(echo "scale=2; $total_points / $elapsed" | bc)
    log info "Addition completed in ${elapsed}s (${points_per_sec} points/sec)"
    log info "Created updated velocity model: vfile.updated"
    return 0
}

# -----------------------------------------------------------------------------
# Main Workflow
# -----------------------------------------------------------------------------
main_workflow() {
    log info "Starting velocity update workflow"

    # Step 0: Input file check
    check_input_files

    if [ ! -f "residuotot.dat" ]; then
        log error "Run VelocityAnalysis.sh first to generate residuotot.dat"
        exit 1
    fi

    if [ ! -f "vfile" ]; then
        log error "Missing required input file: vfile"
        exit 1
    fi

    # Step 0.1: Parameter file handling
    log info "Checking v.par_v parameter file..."
    if [ ! -f "v.par_v" ]; then
        log warn "v.par_v not found. Launching parameter setup..."       
    fi
    choose_param_mode

    # Step 0.5: Backup original velocity file
    if [ -f vfile ]; then
        cp vfile vfile_old
        log info "Backed up original velocity file to vfile_old"
    fi

    # Step 1: Compile Fortran dependencies
    compile_embedded_faivelres || {
        log error "Fortran compilation failed"
        return 1
    }

    # Step 2: Prepare environment
    log info "Preparing workspace..."
    rm -f vfile.a

    # Step 3: Convert vfile to ASCII if needed
    b2a <vfile n1=1 >vfile.a

    # Step 4: Interpolate velocity residuals (using Fortran)
    log info "Performing 2D velocity interpolation..."
    ./faivelres || {
        log error "Velocity interpolation failed"
        return 1
    }

    # Step 5: Update velocity model
    add_velocity_models || {
        log error "Velocity model addition failed"
        return 1
    }

    # Step 6: Finalize
    log info "Finalizing velocity update..."
    a2b < vfile.updated n1=1 > vfile
    rm -f vfile.updated

    # Step 7: Cleanup temporary files
    log info "Cleaning up temporary files..."
    rm -f vfile.a temp

    log info "Velocity update completed successfully"
    return 0
}

# -----------------------------------------------------------------------------
# Script Entry Point
# -----------------------------------------------------------------------------
if [ "$(id -u)" -eq 0 ]; then
    log warn "Running as root is not recommended"
fi

# Check for Seismic Unix
if ! command -v suwind &> /dev/null; then
    log error "Seismic Unix (SU) not found in PATH"
    log error "Please install SU and ensure it's in your PATH"
    exit 1
fi

# Execute main workflow
start_time=$(date +%s)
main_workflow
exit_code=$?
end_time=$(date +%s)
duration=$((end_time - start_time))

if [ $exit_code -eq 0 ]; then
    log info "Workflow completed in ${duration} seconds"
else
    log error "Workflow failed after ${duration} seconds"
fi

exit $exit_code
